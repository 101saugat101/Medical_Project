# from fastapi import FastAPI, HTTPException
# from pydantic import BaseModel
# import psycopg2
# import google.generativeai as genai

# # Initialize FastAPI app
# app = FastAPI()

# # Configure Google Gemini API
# genai.configure(api_key="AIzaSyCHh4vaVl5efQ1Xza9PgovJYDApoHlJ4B8")

# # PostgreSQL Database Configuration
# DB_CONFIG = {
#     "dbname": "doctors_db",
#     "user": "postgres",
#     "password": "heheboii420",
#     "host": "localhost",
#     "port": "5432"  # Default PostgreSQL port; change if different
# }


# # DB_CONFIG = "postgresql://postgres:heheboii420@localhost/doctors_db"

# # Request Model for API
# class QueryRequest(BaseModel):
#     user_input: str


# def connect_to_db():
#     """Establish a connection to PostgreSQL."""
#     try:
#         return psycopg2.connect(**DB_CONFIG)
#     except Exception as e:
#         raise HTTPException(status_code=500, detail=f"Database connection error: {str(e)}")


# def execute_query(query):
#     """Execute a SQL query and return results."""
#     try:
#         conn = connect_to_db()
#         cursor = conn.cursor()
#         cursor.execute(query)
#         results = cursor.fetchall()
#         column_names = [desc[0] for desc in cursor.description]
#         cursor.close()
#         conn.close()
#         return results, column_names
#     except Exception as e:
#         return str(e), []






# def generate_sql(user_input):
#     """Convert user input into a valid PostgreSQL SQL query using Gemini."""
#     prompt = f"""
#     Convert this natural language request into a valid PostgreSQL SQL query.

#     - Table name: 'doctor_schedule'
#     - Columns: 
#       - 'day_of_week' (VARCHAR)
#       - 'specialty' (VARCHAR)
#       - 'doctor_name' (VARCHAR)
#       - 'time_slot' (VARCHAR)

#     **Rules:**
#     1. The SQL query must use `SELECT` statements only.
#     2. Do NOT return "sql" or any explanations before or after the query.
#     3. Do NOT wrap the SQL query in code blocks like ```sql ... ```.
#     4. Ensure correct PostgreSQL syntax.

#     **Example Queries:**
#     - User: "Who is available on Monday?"
#       SQL: SELECT doctor_name, specialty, time_slot FROM doctor_schedule WHERE day_of_week = 'Monday';

#     - User: "Which doctor is available on Friday at 10 AM?"
#       SQL: SELECT doctor_name, specialty, time_slot FROM doctor_schedule WHERE day_of_week = 'Friday' 
#             AND time_slot LIKE '%10:00 AM%';

#     **User Input:** "{user_input}"
#     """
    
#     sql_query = process_with_gemini(prompt)

#     # Debug output
#     print(f"Raw SQL output from Gemini:\n{sql_query}")

#     # Clean SQL output
#     sql_query = sql_query.strip().replace("```sql", "").replace("```", "").strip()

#     # Ensure the query starts with SELECT
#     if not sql_query.lower().startswith("select"):
#         raise HTTPException(status_code=400, detail="Invalid SQL Query generated by Gemini.")

#     print(f"Final cleaned SQL query:\n{sql_query}")
#     return sql_query

# def process_with_gemini(prompt):
#     """Send prompt to Google Gemini for processing."""
#     model = genai.GenerativeModel("gemini-2.0-flash")
#     response = model.generate_content(prompt)
#     return response.text

# @app.post("/availability/")
# def check_doctor_availability(request: QueryRequest):
#     """Handles user queries, translates to SQL, executes, and returns Gemini-processed response."""
#     user_input = request.user_input

#     # Generate SQL query from user input
#     sql_query = generate_sql(user_input)
    
#     # Debugging: Print SQL before executing
#     print(f"Generated SQL Query:\n{sql_query}")

#     if not sql_query.lower().startswith("select"):
#         raise HTTPException(status_code=400, detail="Invalid SQL Query generated by Gemini.")

#     # Execute the SQL query
#     results, columns = execute_query(sql_query)

#     if isinstance(results, str):  # Error handling
#         raise HTTPException(status_code=400, detail=f"SQL Error: {results}")

#     # Process results with Gemini for a meaningful response
#     structured_output = process_with_gemini(f"""
#     The user asked: {user_input}
#     The SQL query executed: {sql_query}
#     Query results (columns: {columns}): {results}

#     Format the output in an easy-to-read summary and provide relevant insights.
#     """)

#     return {"sql_query": sql_query, "response": structured_output}


# if __name__ == "__main__":
#     import uvicorn
#     uvicorn.run(app, host="0.0.0.0", port=8000)



from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import psycopg2
import google.generativeai as genai
import json
# Initialize FastAPI app
app = FastAPI()

# Configure Google Gemini API
genai.configure(api_key="AIzaSyCHh4vaVl5efQ1Xza9PgovJYDApoHlJ4B8")

# PostgreSQL Database Configuration
DB_CONFIG = {
    "dbname": "doctors_db",
    "user": "postgres",
    "password": "heheboii420",
    "host": "localhost",
    "port": "5432"  # Default PostgreSQL port; change if different
}


# DB_CONFIG = "postgresql://postgres:heheboii420@localhost/doctors_db"

# Request Model for API
class QueryRequest(BaseModel):
    user_input: str


def connect_to_db():
    """Establish a connection to PostgreSQL."""
    try:
        return psycopg2.connect(**DB_CONFIG)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database connection error: {str(e)}")


def execute_query(query):
    """Execute a SQL query and return results."""
    try:
        conn = connect_to_db()
        cursor = conn.cursor()
        cursor.execute(query)
        results = cursor.fetchall()
        column_names = [desc[0] for desc in cursor.description]
        cursor.close()
        conn.close()
        return results, column_names
    except Exception as e:
        return str(e), []


def extract_query_parameters(user_input):
    """Extract day, time, and specialty from user input using Gemini."""
    prompt = f"""
    Extract relevant details from the following natural language query.

    The user might mention:
    - A **day of the week** (e.g., Monday, Friday, Sunday).
    - A **specific time** (e.g., 10 AM, 2 PM).
    - A **specialty** (e.g., Cardiology, Dermatology, Osteology).

    Return only a JSON object with the following structure:
    {{
        "day_of_week": "Extracted Day or null if not mentioned",
        "time": "Extracted Time or null if not mentioned",
        "specialty": "Extracted Specialty or null if not mentioned"
    }}

    **Examples:**
    - User: "Which doctors are available on Sunday?"
      Output: {{"day_of_week": "Sunday", "time": null, "specialty": null}}

    - User: "Who is available on Friday at 10 AM?"
      Output: {{"day_of_week": "Friday", "time": "10:00 AM", "specialty": null}}

    - User: "Which Cardiologists are free on Wednesday at 2 PM?"
      Output: {{"day_of_week": "Wednesday", "time": "02:00 PM", "specialty": "Cardiology"}}

    **User Input:** "{user_input}"
    """

    extracted_info = process_with_gemini(prompt)

    # Debugging: Print what Gemini returns
    print(f"Raw Gemini Response:\n{extracted_info}")

    # Clean response in case Gemini adds extra text
    extracted_info = extracted_info.strip().replace("```json", "").replace("```", "").strip()

    try:
        parsed_json = json.loads(extracted_info)  # Convert Gemini output to JSON
        print(f"Extracted JSON Data: {parsed_json}")  # Debugging
        return parsed_json
    except json.JSONDecodeError as e:
        print(f"JSON Decode Error: {e}")  # Debugging
        raise HTTPException(status_code=400, detail="Error extracting query parameters.")
 
def generate_sql(user_input):
    """Construct SQL query manually based on extracted parameters."""
    query_params = extract_query_parameters(user_input)

    day_of_week = query_params.get("day_of_week")
    time = query_params.get("time")
    specialty = query_params.get("specialty")

    # Start building the SQL query
    sql_query = "SELECT doctor_name, specialty, time_slot FROM doctor_schedule WHERE 1=1"

    # Add filters based on extracted parameters
    if day_of_week:
        sql_query += f" AND day_of_week = '{day_of_week}'"
    if time:
        sql_query += f" AND time_slot LIKE '%{time}%'"
    if specialty:
        sql_query += f" AND specialty = '{specialty}'"

    print(f"Final constructed SQL Query:\n{sql_query}")  # Debugging
    return sql_query


def process_with_gemini(prompt):
    """Send prompt to Google Gemini for processing and return clean text."""
    model = genai.GenerativeModel("gemini-2.0-flash")  # Ensure the model is correct
    response = model.generate_content(prompt)
    
    # Debugging: Print what Gemini returns
    print(f"Raw Gemini Output:\n{response.text}")

    return response.text

@app.post("/availability/")
def check_doctor_availability(request: QueryRequest):
    """Handles user queries, translates to SQL, executes, and returns Gemini-processed response."""
    user_input = request.user_input

    # Generate SQL query from user input
    sql_query = generate_sql(user_input)
    
    # Debugging: Print SQL before executing
    print(f"Generated SQL Query:\n{sql_query}")

    if not sql_query.lower().startswith("select"):
        raise HTTPException(status_code=400, detail="Invalid SQL Query generated by Gemini.")

    # Execute the SQL query
    results, columns = execute_query(sql_query)

    if isinstance(results, str):  # Error handling
        raise HTTPException(status_code=400, detail=f"SQL Error: {results}")

    # Process results with Gemini for a meaningful response
    structured_output = process_with_gemini(f"""
    The user asked: {user_input}
    The SQL query executed: {sql_query}
    Query results (columns: {columns}): {results}

    Format the output in an easy-to-read summary and provide relevant insights.
    """)

    # return {"sql_query": sql_query, "response": structured_output}
    return { "response": structured_output}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
